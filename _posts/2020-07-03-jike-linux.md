---
layout: post
title: "极客时间《Linux 性能优化实战》笔记"
categories: notes
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [CPU 性能篇](#cpu-性能篇)
  - [平均负载](#平均负载)
    - [是什么](#是什么)
    - [平均负载为多少时合理](#平均负载为多少时合理)
    - [平均负载与 CPU 使用率](#平均负载与-cpu-使用率)
    - [测试平均负载的工具](#测试平均负载的工具)
  - [CPU 上下文切换](#cpu-上下文切换)
    - [CPU 上下文](#cpu-上下文)
    - [进程上下文切换](#进程上下文切换)
    - [线程上下文切换](#线程上下文切换)
    - [中断上下文切换](#中断上下文切换)
    - [查看上下文切换的工具](#查看上下文切换的工具)
  - [CPU 使用率](#cpu-使用率)
    - [查看 CPU 使用率的工具](#查看-cpu-使用率的工具)
    - [查找占用 CPU 的代码函数](#查找占用-cpu-的代码函数)
- [内存](#内存)
  - [内存](#内存-1)
- [IO](#io)
  - [Linux 文件系统](#linux-文件系统)

<!-- /code_chunk_output -->

# CPU 性能篇

## 平均负载

### 是什么

```sh
$ uptime
02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88
```

分别是当前时间、系统运行时间以及正在登录用户数。最后的三个数字，依次则是过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。

平均负载是指单位时间内，系统处于**可运行状态**和**不可中断状态**的平均进程数，也就是**平均活跃进程数**，和 CPU 使用率并没有直接关系。

- 所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。

- 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。

### 平均负载为多少时合理

假如 CPU 核心有 6 个，则平均负载比 CPU 个数还大的时候，系统已经出现了过载。

作者认为，当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。

### 平均负载与 CPU 使用率 

- CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
- I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；
- 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。

### 测试平均负载的工具

**stress** 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。

```sh
# 模拟一个 CPU 使用率 100% 的场景
$ stress --cpu 1 --timeout 600
```

**sysstat** 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。包含的 **mpstat** 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。而 **pidstat** 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标

```sh
# -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
$ mpstat -P ALL 5

# 间隔5秒后输出一组数据，-u 表示CPU指标，以 CPU 使用率从高到低排行
$ pidstat -u 5 1
```

## CPU 上下文切换

### CPU 上下文

Linux 是一个多任务操作系统，每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 **CPU 寄存器**和**程序计数器**（Program Counter，PC）。

- CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。

- 程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。

它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 **CPU 上下文**。

**任务是什么：** 进程和线程是最常见的任务，硬件通过触发信号，会导致中断处理程序的调用，也是一种常见的任务。

**CPU 上下文切换 :** 就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

根据任务的不同，CPU 上下文切换就可以分为几个不同的场景，也就是**进程上下文切换**、**线程上下文切换**以及**中断上下文切换**。

### 进程上下文切换

Linux 把进程的运行空间分为**内核空间**和**用户空间**。

- 内核空间具有最高权限，可以直接访问所有资源；

- 用户空间能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。

进程在用户空间运行时，被称为进程的**用户态**，而陷入内核空间的时候，被称为进程的**内核态**。

从用户态到内核态的转变，需要通过**系统调用**来完成。

系统调用时，CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。系统调用结束后，还得切换回用户空间。所以，**一次系统调用的过程，发生了两次 CPU 上下文切换**。

系统调用过程中一直是同一个进程在运行, 而**进程上下文切换**是指从一个进程切换到另一个进程运行。

进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。

进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。

**进程被调度到 CPU 上运行的情况：**

- 进程执行完终止了，之前使用的 CPU 会释放出来，这个时候 CPU 再从就绪队列里，拿一个新的进程过来运行。

- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。

- 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。

- 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。

- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。

- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。

### 线程上下文切换

线程与进程最大的区别在于，**线程是调度的基本单位，而进程则是资源拥有的基本单位**。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。所以，对于线程和进程，我们可以这么理解：

- 当进程只有一个线程时，可以认为进程就等于线程。

- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。

- 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

**线程的上下文切换**其实就可以分为两种情况：

- 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。

- 前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。

### 中断上下文切换

为了快速响应硬件的事件，**中断处理会打断进程的正常调度和执行**，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。

中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。

**对同一个 CPU 来说，中断处理比进程拥有更高的优先级。**

### 查看上下文切换的工具

**sysbench** 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。

```sh
# 以10个线程运行5分钟的基准测试，模拟多线程切换的问题
$ sysbench --threads=10 --max-time=300 threads run
```

**vmstat** 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

```sh
# 每隔5秒输出1组数据，展示系统总体的上下文切换情况
$ vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- 
r  b   swpd   free    buff   cache   si  so  bi  bo in  cs  us  sy  id  wa  st 
0  0   0      7005360 91564  818900  0   0   0   0  25  33  0   0   100 0   0
```

cs（context switch）是每秒上下文切换的次数。  
in（interrupt）则是每秒中断的次数。  
r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。  
b（Blocked）则是处于不可中断睡眠状态的进程数。

**pidstat** ，要想查看每个进程的详细情况，就需要使用我们前面提到过的 pidstat 了。

```sh
# 每隔5秒输出1组数据
$ pidstat -w 5
Linux 4.15.0 (ubuntu) 09/23/18 _x86_64_ (2 CPU)
08:18:26    UID     PID     cswch/s     nvcswch/s   Command
08:18:31    0       1       0.20        0.00        systemd
08:18:31    0       8       5.40        0.00        rcu_sched
```

cswch/s ，表示每秒**自愿上下文切换**（voluntary context switches）的次数。  
nvcswch/s ，表示每秒**非自愿上下文切换**（non voluntary context switches）的次数。

- 自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。

- 非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。

**/proc/interrupts** 就是这种通信机制的一部分，提供了一个只读的中断使用情况。/proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。

```sh
# -d 参数表示高亮显示变化的区域
$ watch -d cat /proc/interrupts
```

## CPU 使用率

### 查看 CPU 使用率的工具

CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比，用公式来表示就是：**CPU 使用率 = 1 - 空闲时间 / 总 CPU 时间**

可以使用 **top** 命令显示了系统总体的 CPU 和内存使用情况，但并没有细分进程的用户态 CPU 和内核态 CPU。所以依然使用 **pidstat** 命令去分析每个进程 CPU 使用情况。

### 查找占用 CPU 的代码函数

针对线下应用，可使用 **GDB**（The GNU Project Debugger），这个功能强大的程序调试利器。

针对线上应用，可使用 **perf**，perf 是Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。

```sh
$ perf top
Samples: 833 of event 'cpu-clock', Event count (approx.): 97742399
Overhead  Shared Object   Symbol 
  7.28%   perf            [.] 0x00000000001f78a4 
  4.72%   [kernel]        [k] vsnprintf 
  4.32%   [kernel]        [k] module_get_kallsym 
  3.65%   [kernel]        [k] _raw_spin_unlock_irqrestore
```

- 第一行包含三个数据，分别是采样数（Samples）、事件类型（event）和事件总数量（Event count）。比如这个例子中，perf 总共采集了 833 个 CPU 时钟事件，而总事件数则为 97742399。

- 第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。

- 第二列 Shared，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。

- 第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。

- 最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。

perf top 是实时的，可以使用 **perf record** 来保存数据，使用 **perf report** 解析展示。可以为 perf top 和 perf record 加上 -g 参数，开启调用关系的采样，方便我们根据调用链来分析性能问题。

```sh
$ perf record # 按Ctrl+C终止采样
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.452 MB perf.data (6093 samples) ]

# 展示类似于perf top的报告
$ perf report 
```

# 内存

## 概念

物理内存也称为主存，大多数计算机用的主存都是动态随机访问内存（DRAM）。只有内核才可以直接访问物理内存。Linux 内核给每个进程都提供了一个独立的 **虚拟地址空间**，并且这个地址空间是连续的。

虚拟地址空间的内部又被分为 **内核空间** 和 **用户空间** 两部分。进程在用户态时，只能访问用户空间内存；只有进入内核态后，才可以访问内核空间内存。

并不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过 **内存映射** 来管理的。

内存映射，其实就是将 **虚拟内存地址** 映射到 **物理内存地址** 。为了完成内存映射，内核为每个进程都维护了一张 **页表**，记录虚拟地址与物理地址的映射关系。

页是内存的最小存储单位，大小通常为 4 K。

### 虚拟内存空间分布

1. 只读段，包括代码和常量等。
2. 数据段，包括全局变量等。
3. 堆，包括动态分配的内存，从低地址开始向上增长。
4. 文件映射段，包括动态库、共享内存等，从高地址开始向下增长。
5. 栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。在这五个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的

### 内存的释放

- 回收缓存，比如使用 LRU 算法，回收最近使用最少的内存页面。

- 回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中。

- 杀死进程，内存紧张时系统还会通过 OOM (Out of Memory)，直接杀掉占用大量内存的进程。

### 查看内存使用

```sh
$ free
        total     used    free      shared    buff/cache    available
Mem:    8169348   263524  6875352   668       1030472       7611064
Swap:   0         0       0 
```

- used 是已使用内存的大小，包含了共享内存; 

- shared 是共享内存的大小；

- buff/cache 是缓存和缓冲区的大小；

- available 是新进程可用内存的大小，不仅包含未使用内存 free，还包含了可回收的缓存。

```sh
$ top
...
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
...
```

- **VIRT** 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。

- **RES** 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。

- **SHR** 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。

## proc 文件系统

/proc 是 Linux 内核提供的一种特殊文件系统，是用户跟内核交互的接口。proc 文件系统同时也是很多性能工具的最终数据来源。比如我们刚才看到的 free ，就是通过读取 /proc/meminfo ，得到内存的使用情况。

Buffers 是内核缓冲区用到的内存，对应的是 /proc/meminfo 中的 Buffers 值。Cache 是内核页缓存和 Slab 用到的内存，对应的是 /proc/meminfo 中的 Cached 与 SReclaimable 之和。

- Buffers 是对原始磁盘块的临时存储，也就是用来缓存磁盘的数据，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等等。

- Cached 是从磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。

- 简单来说，Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中。

- SReclaimable 是 Slab 的一部分。Slab 包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。

# IO

##　Linux 文件系统

Linux 文件系统为每个文件都分配两个数据结构，**索引节点**（index node）和 **目录项**（directory entry）。它们主要用来记录文件的元信息和目录结构。

－ 索引节点，简称为 inode，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。

－ 目录项，简称为 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。

磁盘读写的最小单位是 **扇区**，扇区通常有 **512B**，文件系统将连续的扇区组成了**逻辑块**，然后每次都以逻辑块为最小单位来管理数据。

所以扇区是磁盘的最小存储单位，而磁盘块是文件系统读写数据的最小单位。

目录项、索引节点、逻辑块以及超级块，构成了 Linux 文件系统的四大基本要素。

## 虚拟文件系统

虚拟文件系统 VFS(Virtual File System) 定义了一组所有文件系统都支持的数据结构和标准接口，用户进程通过 VFS 提供的统一接口和文件系统交互，而不需要关心底层各种文件系统的实现细节。

文件系统根据存储位置的不同，分三类：

- 基于磁盘的问价那系统，常见为 Ext4、XFS、OverlayFS 等。

- 基于内存的文件系统，即虚拟文件系统，不需要磁盘分配存储空间，但会占用内存。常见如 /proc、/sys 等，主要想用户空间导出层次化的内核对象。

- 网络文件系统，也就是用来访问其他计算机数据的文件系统，比如 NFS、SMB、iSCSI 等。

## 文件系统 I/O

常见的 I/O 有**缓冲与非缓冲I/O、直接与非直接I/O、阻塞与非阻塞I/O、同步与异步I/O**。

- 第一种，根据是否利用标准库缓存，可以把文件 I/O 分为缓冲 I/O 与非缓冲 I/O。 （缓冲是指标准库内部实现的缓存）

缓冲 I/O，是指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调度访问文件。

非缓冲 I/O，是指直接通过系统调用来访问文件，不再经过标准库缓存。

- 第二，根据是否利用操作系统的页缓存，可以把文件 I/O 分为直接 I/O 与非直接 I/O。

直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。

非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。

想要实现直接 I/O，需要你在系统调用中，指定 O_DIRECT 标志。如果没有设置过，默认的是非直接 I/O。不过要注意，直接 I/O、非直接 I/O，本质上还是和文件系统交互。如果是在数据库等场景中，还有跳过文件系统读写磁盘的情况，也就是通常所说的裸 I/O。

- 第三，根据应用程序是否阻塞自身运行，可以把文件 I/O 分为阻塞 I/O 和非阻塞 I/O：

所谓阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务。

所谓非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。

比方说，访问管道或者网络套接字时，设置 O_NONBLOCK 标志，就表示用非阻塞方式访问；而如果不做任何设置，默认的就是阻塞访问。

- 第四，根据是否等待响应结果，可以把文件 I/O 分为同步和异步 I/O：

所谓同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。

所谓异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序。

举个例子，在操作文件时，如果你设置了 O_SYNC 或者 O_DSYNC 标志，就代表同步 I/O。如果设置了 O_DSYNC，就要等文件数据写入磁盘后，才能返回；而 O_SYNC，则是在 O_DSYNC 基础上，要求文件元数据也要写入磁盘后，才能返回。

再比如，在访问管道或者网络套接字时，设置了 O_ASYNC 选项后，相应的 I/O 就是异步 I/O。这样，内核会再通过 SIGIO 或者 SIGPOLL，来通知进程文件是否可读写。

这里的好多概念也经常出现在网络编程中。比如非阻塞 I/O，通常会跟 select/poll 配合，用在网络套接字的 I/O 中。

**无论是普通文件和块设备、还是网络套接字和管道等，它们都通过统一的 VFS 接口来访问。**

